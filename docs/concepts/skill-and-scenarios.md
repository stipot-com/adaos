# Архитектура навыков, сценариев и состояния в AdaOS

## 1. Цели

Эта схема нужна, чтобы:

* сохранить **общность OS** (ядро не завязано на конкретный UI или workflow);
* сделать **навыки переиспользуемыми и тестируемыми**;
* позволить **сценариям расширять поведение** (workflow, композиция, «Доброе утро», desktop и т.п.);
* спрятать детали Yjs и других хранилищ за стабильным логическим API.

---

## 2. Базовые сущности

### 2.1. Навык (Skill)

Навык — базовая единица функциональности в AdaOS.

Навык:

* имеет манифест `skill.yaml`;
* может иметь описание UI-поверхностей (например, `webio.json`);
* реализует обработчики событий / запросов.

Навык **может быть stateful внутри себя** (свои FSM, кэши, коннекты и т.п.), но с точки зрения платформы он работает через стабильный контракт:

```text
event + ctx + skill_memory → effects
```

Где:

* `event` — входящее событие/запрос;
* `ctx` — логический общий контекст (shared state);
* `skill_memory` — приватная память навыка;
* `effects` — результат: изменения контекста, новые события, ответы UI и т.п.

Навык должен работать **без обязательного наличия сценария**: через CLI, чат, голос или как одиночный web-виджет.

---

### 2.2. Память навыка (Skill Memory)

`skill_memory` — приватное состояние навыка, к которому **нет прямого доступа у других навыков и сценариев**.

Используется для:

* внутренних настроек;
* кэшей;
* локальных FSM.

Доступен через SDK навыка.

---

### 2.3. Общий контекст (ctx)

`ctx` — логический общий контекст webspace / подсети.

Характеристики:

* обращение по логическим путям вида `user.profile`, `desktop.widgets`, `voice.morning.current_step`;
* навыки читают и записывают состояние только через `ctx`;
* **физическая реализация `ctx` скрыта**: под капотом это может быть Yjs, БД, in-memory store, комбинация.

Примеры использования:

```python
profile = ctx.get("user.profile")
ctx.patch("desktop.widgets", new_widgets)
ctx.set("voice.morning.current_step", "weather")
```

Навыку не нужно знать, где именно лежат эти данные — это работа ядра и сценария.

---

### 2.4. Сценарий (Scenario)

Сценарий — **опциональная надстройка** над набором навыков.

Сценарий используется, когда нужно:

* задать **workflow** (пошаговый сценарий, мастер, диалог);
* **скомпоновать несколько навыков** в одно приложение (desktop, «рабочее место»);
* описать **role-based политики и расширяемость** (extension points).

Сценарий:

* имеет манифест `scenario.yaml` (описательная часть);
* может иметь содержательную часть `scenario.json` (layout, режимы, переходы и т.п.);
* работает как **оркестратор**, но не как обязательный слой под каждый навык.

Навык может существовать без сценария; сценарий — расширяет поведение в тех случаях, когда это нужно.

---

## 3. Состояние: слои и границы

В AdaOS выделяем несколько уровней состояния:

1. **Skill Memory**
   приватно для навыка.

2. **Shared Context (`ctx`)**
   логический общий контекст webspace/subnet.
   Делится условно на:

   * `ctx.user.*` — профиль и пользовательские данные;
   * `ctx.global.*` — общие сущности (таски, календарь, настройки);
   * `ctx.ui.*` — UI-специфичные состояния по каналам.

3. **UI-состояние по каналам** (поверх `ctx`):

   * `ctx.ui.web.*` — web / desktop;
   * `ctx.ui.chat.*` — чат-интерфейс;
   * `ctx.ui.voice.*` — голосовые сценарии.

Навык видит только `ctx` и `skill_memory`.
Какие части `ctx` реализованы через Yjs, а какие через БД — решает runtime.

---

## 4. Роль Yjs

Yjs используется как **движок синхронизации и хранения UI-состояния**, в первую очередь для web-интерфейса.

### 4.1. Кто владеет Yjs

* **Сценарий/webspace-runtime** владеет Yjs-документами:

  * описывает, какие Y-доки нужны;
  * описывает mapping: какие логические пути `ctx.*` живут в Yjs;
  * поднимает соединения, синхронизацию и т.п.

* **Навыкам не нужно знать про Yjs напрямую.**
  Официальный путь — работа через `ctx`.

### 4.2. Доступ навыков к Yjs

* Прямой доступ к Yjs из кода навыка **не является частью стандартного SDK** и рассматривается как low-level/escape hatch для редких кейсов.
* Для большинства навыков и сценариев достаточно и **предпочтительно** использовать только `ctx`.

Таким образом:

> Yjs — это реализация части `ctx`, а не публичный контракт API для навыков.

---

## 5. Сценарии как расширение навыков

Сценарий не заменяет навыки, а **расширяет их**:

* берёт один или несколько навыков;
* поверх них задаёт:

  * последовательность шагов / режимов;
  * правила переходов;
  * композицию UI;
  * расширяемость через точки подключения.

Навык остаётся самодостаточным (может жить и без сценария), сценарий добавляет:

* «desktop» поверх набора виджетов;
* голосовой сценарий «Доброе утро» поверх погоды, календаря, новостей;
* onboarding, мастера, сложные диалоги и т.п.

---

## 6. Модель расширяемости: extension points и contributions

Чтобы сценарии могли автоматически «обогащаться» при установке новых совместимых навыков, вводится модель:

### 6.1. Extension points (точки расширения сценария)

Сценарий объявляет точки расширения, в которые могут подключаться навыки.

Примеры:

```yaml
# scenario.yaml (desktop)
extension_points:
  - id: desktop.main.widget
    kind: widget

# scenario.yaml (Доброе утро)
extension_points:
  - id: morning.segment
    kind: voice_segment
    order: sequential
```

### 6.2. Contributions (вклады навыков)

Навык в своём манифесте объявляет, что он может предложить сценарию:

```yaml
# skill.yaml (weather)
contributions:
  - to: desktop.main.widget
    when:
      scenario_type: desktop
    provides:
      widget: "weather.main"
      title: "Погода"

  - to: morning.segment
    when:
      scenario_type: voice.morning_routine
    provides:
      segment_id: "weather_brief"
      order_hint: 20
```

Runtime:

* видит новые навыки и их `contributions`;
* сопоставляет их с `extension_points` сценариев;
* по политике (авто-добавить, предложить пользователю, выключено по умолчанию) подключает их в конфигурацию сценария.

Конфигурация сценария (`ctx.ui.desktop.*`, `ctx.ui.voice.morning.*`) хранит:

* какие contributions активны;
* их порядок;
* дополнительные настройки (позиция, размер, права).

---

## 7. Каналы: desktop и голосовые сценарии

### 7.1. Desktop-сценарий

* Тип: `scenario_type: desktop`.
* Использует Yjs для:

  * layout (зоны, окна, виджеты);
  * локального UI-состояния (раскрыто/свернуто, размеры и т.п.).
* Навыки предоставляют виджеты через `webio.json` и `contributions`.
* Сценарий:

  * объявляет extension points для виджетов;
  * управляет конфигурацией включённых contributions в `ctx.ui.web.desktop.*`;
  * выступает оператором mapping `ctx <→ Yjs`.

### 7.2. Голосовой сценарий «Доброе утро»

* Тип: `scenario_type: voice.morning_routine`.
* Может **вообще не использовать Yjs**, опираясь только на `ctx`:

  * `ctx.user.profile` → профиль пользователя;
  * `ctx.voice.morning.current_step` → текущий шаг;
  * `ctx.voice.morning.segments` → активные сегменты.
* Навыки предоставляют голосовые сегменты через `contributions`.
* Сценарий управляет:

  * порядком сегментов,
  * переходами,
  * сохранением промежуточного состояния (какие сегменты уже отыграны).

При желании часть этого состояния может маппиться в Yjs, чтобы показывать историю/конфигурацию в web-интерфейсе, но это детали реализации, не контракт для навыков.

---

## 8. Рекомендации по разработке

1. **Навык:**

   * работает через `event + ctx + skill_memory → effects`;
   * не завязан на Yjs напрямую;
   * может быть использован без сценария.

2. **Сценарий:**

   * использует навыки как кирпичи;
   * задаёт workflow, режимы, layout (если есть UI);
   * объявляет `extension_points` и читает `contributions`;
   * управляет data-model’ю в рамках своего runtime, включая mapping `ctx → Yjs/БД`.

3. **Yjs:**

   * используется только на уровне сценария/runtime webspace;
   * не входит в стандартный публичный API `sdk` для навыков.
